Sorting pseudocode - numbers:
	for i=0 to size of subarray-2
		lock n[i] and n[i+1]
		if n[i] is a number and n[i+1] or they're both letters/numbers and n[i] is larger than n[i+1]
			switch them
		else do nothing
		unlock n[i] and n[i+1]

Solves the problem because: This results in all numbers being to the left of letters within each sub array, it also results in larger number/letters being to the right of smaller numbers/letters.


Sorting pseudocode - letters:
	for i=0 to size of subarray-2
		lock l[i] and l[i+1]
		if l[i] is larger than l[i+1]
			switch them
		else do nothing
		unlock l[i] and l[i+1]

Solves the problem because: This results in larger/numbers being to the right of smaller numbers/letters, since we only care about numbers less than 10, we can do this with simpler logic than for numbers, because the value of numbers is smaller than the value of letters.


Exchanging pseudocode:
	for i=0 to size of subarray-1
		lock n[i] and l[i]
		if n[i] is a letter and l[i] is a number
			switch them
		else do nothing
		unlock n[i] and l[i]

This function in the real code, only exchanges elements if both elements at a given index are in the wrong array.

Checking f sorted pseudocode:
	for i=0 to size of fullarray
		lock a[i] and a[i+1]
		if a[i] is larger than a[i+1]
			unlock both
			return 0
		unlock both
	return 1

If at any point the array is not sorted, this code will short circuit and return false, otherwise if it makes it to the end it knows that the array is sorted so it returns true. It's important to check the entire array in order to avoid the case where the process thinks its part of the array is sorted, so stops sorting, before the entire array is sorted. In that case another process may move an out of order element into its sub array and it would never notice and finish sorting.

main pseudocode
	create shared memory for both arrays
	create semaphore set
	initialize values to 1
	get input from user for array
	if input valid
		put input in arrays
	else
		use default array
	print starting arrays

	create children with unique value to differentiate
	while either array is unsorted
		each process sorts its sub array
	children exit, parent waits
	parent prints final arrays
	parent cleans up shared memory
	exit



Critical section discussion:
	1. Mutual exclusion: There are semaphores for each index in each of the two arrays. Before the program even begins to do any of the comparisons it locks both of the values necessary, so that it can be sure that no other processes are reading or writing to that location, ensuring that mutal exclusion is satisfied.
	2. Progress: If no other process is using the values that the active process needs to do its comparison/etc then it immediately enters the critical section. If they are locked, it will wait for them to be freed, and join the queue, each process will free its semaphores after it has done its comparisons, allowing other processes to enter their critical sections.
	3. Bounded waiting: If a process attempts to access an element that has been locked by another process, it will be unable due to the lock. It will wait for the other process to finish doing whatever comparisons and swaps its doing before continuing. The semaphores in linux implement a wait queue, so it is ensured that that process will get a chance to do operations on those elements. The cyclical nature of the sort and exchange algorithms also helps to limit the amount of time that any one process will wait on a single element.
